//-------------------------------------------------------------------------------------------
// MetaCore
// Author: Chris Moore, 0xCM@gmail.com
// License: MIT
//-------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

partial class Reflections
{

    /// <summary>
    /// Determines an expression for the name of the method relative to the supplied type parameter
    /// </summary>
    /// <typeparam name="R"></typeparam>
    /// <param name="m">The method for which a name relative to  <typeparamref name="R"/></param> will be specified
    /// <returns></returns>
    public static string RelativeName<R>(this MethodBase m)
        => typeof(R).Name
        + $"/{m.Name.Replace(typeof(R).FullName + ".", string.Empty)}";

    /// <summary>
    /// Gets the value of a specified field or property
    /// </summary>
    /// <param name="m">The field or property</param>
    /// <param name="o">The object on which the member is defined</param>
    /// <returns></returns>
    public static object GetMemberValue(this MemberInfo m, object o)
    {
        if (m is FieldInfo)
            return (m as FieldInfo).GetValue(o);
        else if (m is PropertyInfo)
            return (m as PropertyInfo).GetValue(o);
        else
            throw new NotSupportedException();
    }


    /// <summary>
    /// Gets the value of the identified member field or property
    /// </summary>
    /// <typeparam name="T">The value type</typeparam>
    /// <param name="m">The member</param>
    /// <param name="o">The instance from which to access the member</param>
    /// <returns></returns>
    [DebuggerStepThrough]
    public static T GetMemberValue<T>(this MemberInfo m, object o)
        => (T)m.GetMemberValue(o);

    /// <summary>
    /// Determines whether a field has been generated by the compiler
    /// </summary>
    /// <param name="f">The field to examine</param>
    /// <returns></returns>
    public static bool IsCompilerGenerated(this FieldInfo f)
        => f.HasAttribute<CompilerGeneratedAttribute>();

    /// <summary>
    /// Creates a report that specifies disagreement between property values, when both properties are defined
    /// on supplied objects
    /// </summary>
    /// <param name="x">An object</param>
    /// <param name="y">An object</param>
    /// <returns></returns>
    public static IDictionary<string, Tuple<object, object>> ComputePropertyValueDelta(object x, object y)
    {
        var delta = new Dictionary<string, Tuple<object, object>>();
        var xprops = x.GetType().GetProperties();
        var yprops = y.GetType().GetProperties();
        foreach (var xprop in xprops)
        {
            var yprop = yprops.FirstOrDefault(z => z.Name == xprop.Name);
            if (yprop != null)
            {
                var xval = xprop.GetValue(x);
                var yval = yprop.GetValue(y);
                if (!Object.Equals(xval, yval))
                {
                    delta[xprop.Name] = Tuple.Create(xval, yval);
                }
            }
        }

        return delta;
    }


    public static IReadOnlyList<Type> GetParameterTypes(this MethodInfo method)
        => method.GetParameters().Select(p => p.ParameterType).ToReadOnlyList();

}