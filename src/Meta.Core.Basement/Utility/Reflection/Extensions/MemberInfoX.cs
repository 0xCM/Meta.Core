//-------------------------------------------------------------------------------------------
// MetaCore
// Author: Chris Moore, 0xCM@gmail.com
// License: MIT
//-------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel;
using System.Linq.Expressions;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

using static CommonBindingFlags;
using static minicore;

partial class Reflections
{

    /// <summary>
    /// Determines an expression for the name of the method relative to the supplied type parameter
    /// </summary>
    /// <typeparam name="R"></typeparam>
    /// <param name="m">The method for which a name relative to  <typeparamref name="R"/></param> will be specified
    /// <returns></returns>
    public static string RelativeName<R>(this MethodBase m)
        => typeof(R).Name
        + $"/{m.Name.Replace(typeof(R).FullName + ".", string.Empty)}";

    /// <summary>
    /// Gets the value of a specified field or property
    /// </summary>
    /// <param name="m">The field or property</param>
    /// <param name="o">The object on which the member is defined</param>
    /// <returns></returns>
    public static object GetMemberValue(this MemberInfo m, object o)
    {
        if (m is FieldInfo)
            return (m as FieldInfo).GetValue(o);
        else if (m is PropertyInfo)
            return (m as PropertyInfo).GetValue(o);
        else
            throw new NotSupportedException();
    }


    /// <summary>
    /// Gets the value of the identified member field or property
    /// </summary>
    /// <typeparam name="T">The value type</typeparam>
    /// <param name="m">The member</param>
    /// <param name="o">The instance from which to access the member</param>
    /// <returns></returns>
    [DebuggerStepThrough]
    public static T GetMemberValue<T>(this MemberInfo m, object o)
        => (T)m.GetMemberValue(o);

    /// <summary>
    /// Determines whether a field has been generated by the compiler
    /// </summary>
    /// <param name="f">The field to examine</param>
    /// <returns></returns>
    public static bool IsCompilerGenerated(this FieldInfo f)
        => f.HasAttribute<CompilerGeneratedAttribute>();

    /// <summary>
    /// Creates a report that specifies disagreement between property values, when both properties are defined
    /// on supplied objects
    /// </summary>
    /// <param name="x">An object</param>
    /// <param name="y">An object</param>
    /// <returns></returns>
    public static IDictionary<string, Tuple<object, object>> ComputePropertyValueDelta(object x, object y)
    {
        var delta = new Dictionary<string, Tuple<object, object>>();
        var xprops = x.GetType().GetProperties();
        var yprops = y.GetType().GetProperties();
        foreach (var xprop in xprops)
        {
            var yprop = yprops.FirstOrDefault(z => z.Name == xprop.Name);
            if (yprop != null)
            {
                var xval = xprop.GetValue(x);
                var yval = yprop.GetValue(y);
                if (!Object.Equals(xval, yval))
                {
                    delta[xprop.Name] = Tuple.Create(xval, yval);
                }
            }
        }

        return delta;
    }


    public static IReadOnlyList<Type> GetParameterTypes(this MethodInfo method)
        => method.GetParameters().Select(p => p.ParameterType).ToReadOnlyList();

    /// <summary>
    /// Searches a type for any method that matches the supplied signature
    /// </summary>
    /// <param name="declaringType">The type to search</param>
    /// <param name="name">The name of the method</param>
    /// <param name="argTypes">The method parameter types in ordinal position</param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Option<MethodInfo> MatchMethod(this Type declaringType, string name, params Type[] argTypes)
        => argTypes.Length != 0
            ? declaringType.GetMethod(name, bindingAttr: AnyVisibilityOrInstanceType,
                        binder: null, types: argTypes, modifiers: null)
            : declaringType.GetMethod(name, AnyVisibilityOrInstanceType);


    /// <summary>
    /// Constructs a reasonably pretty display name for a type
    /// </summary>
    /// <param name="t">The type</param>
    /// <returns></returns>
    public static string DisplayName(this Type t)
    {
        var attrib = t.GetCustomAttribute<DisplayNameAttribute>();
        if (attrib != null)
            return attrib.DisplayName;

        if (!t.IsGenericType)
            return t.Name;

        if (t.IsConstructedGenericType)
        {
            var typeArgs = t.GenericTypeArguments;
            var argFmt = string.Join(",", typeArgs.Select(a => a.DisplayName()).ToArray());
            var typeName = t.Name.Replace($"`{typeArgs.Length}", string.Empty);
            return concat(typeName, "<", argFmt, ">");
        }
        else
        {
            var typeArgs = t.GetGenericTypeDefinition().GetGenericArguments();
            var argFmt = string.Join(",", typeArgs.Select(a => a.DisplayName()).ToArray());
            var typeName = t.Name.Replace($"`{typeArgs.Length}", string.Empty);
            return concat(typeName, "<", argFmt, ">");
        }
    }



}